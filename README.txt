Fifteen Puzzle

Explanation of choices of classes, data structures, algorithms, heuristics, etc.

Class Solver:
This contains the main function that drives the whole process of solving the puzzle. It first opens a puzzle text file through the Class Puzzle, then start a series of target finding which uses their respective heuristic functions (explained later). Finally, it saves the steps toward the final goal into the output text file.

Class Puzzle:
Basically copied from my assignment 1 file, handles the opening of the board text file through its constructor. Also has makeMove() to move the number and isSolved() function used to check whether the goal state is reached.

Class CheckAns – removed from submitted project files: 
This class is used for testing whether a sol.txt file actually solves a board.txt file.

Class BoardGenSolver – removed from submitted project files:
Generates a set of randomly generated boards to be solved and test the solution using class CheckAns.

Class Graph:
This class contains all the graph searching algorithms using heuristics. 
It contains three set of findTarget_xxx functions : findTarget_single, findTarget_3, findTarget_level, each of which has its corresponding equalsTarget_xxx and calAstar_xxx functions.
Basically each findTarget_xxx function uses a HaspMap<Vertex,Vertex> to store all the visited vertices and this HashMap data structure allows quick (O(1)) access to vertices. It also has a PriorityQueue<Vertex> data structure to keep all the vertices that need to be explored, and this PriorityQueue is based on the current cost (steps) plus the estimated future cost from calAstar_xxx function. The equalsTarget_xxx function will compare the newly explored vertex with the its target and the calAstar_xxx will estimate the distance (steps) to the target. Also the action2 ( for findTarget_level,  does not have int[] avoid as parameter) and action3(for the other findTarget_xxx, support int[] avoid) function would generate possible vertices to be added to the PriorityQueue.
All puzzles will be solved in an intrinsically recursive manner. For example, 9x9 puzzles will first need to align the top row and the leftmost column to their corresponding positions (I call this level = 0) and thus it will be reduced to an inner 8x8 puzzle (level = 1) to be solved and repeat this process until 2x2 is solved.

During each recursive step, I would:

1.	Move all the nodes directly to their supposed to be position using findTarget_single. Note that I added an int[] avoid array to keep track of all the numbers that has already been moved to their proper position so that they are not moved again by later progress. Also this move single number is a two step process. For the numbers in the top row, it would first be moved horizontally to its proper X position, then moved vertically to its proper Y position; For the numbers in the leftmost column, it would first be moved vertically to its proper Y position, and then moved horizontally to its proper X position. This two step process both ensures that the previous aligned numbers are not blocking the progress of the new number and it also allow the calAstar_single function to give clearer guidance on how many steps it takes to get to its target (since switching direction is a bit hard to calculate, especially with the int[] avoid in place) which reduces the size of the PriorityQueue. The heuristic function I used calculates the steps needed to achieve the target by manually moving the empty number. For example, to move the number 1 to its proper position in vertical direction step, suppose number 1 is at position (3,0) and empty is at position (4,0) it would cost the empty block an extra cost of 2 to move to position (2,0) so that number 1 can advance to (2,0) with one UP movement.  Each upward movement of a number would cost 5 steps (starting from when the empty block is at its immediate top). This A* value needs to be added the steps that the empty block move toward the immediate top of the number. This resulting sum would be the heuristic function calAstar_single for a vertical findTarget_single function. Very similar is the heuristic function for the horizontal movement. It is important to see that the final number in the top row or the leftmost column cannot be moved to its proper position without moving the number on its left (for the top row) or its top (for the leftmost column), so I would not add that number to the int[] avoid array. And this means that that number (second to top row rightmost or second to leftmost column bottom) would be out of its proper position.

2.	This misalignment would be solved by findTarget_3, which aligns the right most 3 numbers on the top row or the bottom 3 numbers on the leftmost column. I find that this arrangement can be done in a 2x3 grid for the top most row or a 3x2 grid for the left most column. So I would add a virtual wall using int[] avoid array to avoid adding more vertices to the PriorityQueue than absolutely necessary. This hugely reduce the size of the PriorityQueue and speed up the aligning process. I used a heuristics function that calculates the Manhattan distance between the last three numbers and their proper position times a constant, plus the Manhattan distance between the empty block and the row or col next to the 3 numbers times a constant. This is obviously not the most optimal distance but due to the hugely restricted search space due to the wall I mentioned, the search speed is very acceptable.

3.	When this process has reduced the puzzle to 3x3, I start to use a level by level solving algorithms which basically use a heuristic algorithm that calculates the Manhattan distance between numbers and their proper location with a Linear conflict algorithm which add more estimated cost when two numbers are on their proper row or col but not in correct order relative to each other. These heuristic functions are pretty basic but because of the hugely reduced board size (3x3 or 2x2), these algorithms still work in perfectly acceptable time.
In summary, I first recursively turn the big puzzles into step-wise smaller puzzles by only aligning the top row and leftmost column. Then I pushed the numbers at the top row and the leftmost column into their target positions, except the last three numbers in the top row and the leftmost column, which will be aligned separately in a 2x3 or 3x2 confined grid to speed up searching.
With these, I can solve virtually any 9x9 puzzles (generated with 10 millions random moves) under 1 second. This is tested using Class BoardGenSolver and checked using Class CheckAns.

Was one of the heuristics always better? Or different heuristics solved different puzzles?

I feel at different stages of target searching different heuristics should be used. Also using int[] avoid array I can limit the length of the PriorityQueue a lot thus speed up the search process.

Describe which parts were easier, which parts required more time.
Setting up the data structures and input and output were easier because lots of codes are from assignment 1 and concepts are from graph searching in lecture slides.  The difficult part is to design the intermediate targets and design the heuristic function for each of the targets.

Describe what I wrote but then didn’t include in the final project (e.g., switched from one data structure to another)
First, I tried using just Manhattan distance and Linear conflict as heuristic function and no intermediate target to solve puzzles. 3x3 is somewhat solvable, 4x4 not always, 5x5 and above almost has no chance. Then I start to think maybe using artificial neural network to estimate the steps and use that as a heuristic function. After one day of struggling with backward propagation training codes I admit that this might not be the most promising way, at least not with my current knowledge of ANN. Then I talked with my classmate Lucia (Yueran Liu) and she suggested the method of recursively shrinking the puzzle which I think is a great idea. So I started designing the intermediate targets along that direction. Pushing the nodes to their destination start to be a headache which is solved by playing the game and manually count the steps. It is important to understand that this whole search algorithm depends on the estimation of steps toward the target so the more accurate I can count the steps the less unnecessary vertices would be added to the PriorityQueue. Then I hit a bottleneck at the last 3 numbers in the row or col and that turns out really slow to align properly, until I find out the method to add a virtual wall to limit the space of movement to 3x2 or 2x3 grid. At that stage I am already hitting the around 1 second per puzzle mark. But sometimes one or two of the single numbers would take a long time to be pushed to place. Then I found that the int[] avoid was in the way of the push the numbers. At that stage I can either redesign the heuristic function to include the int[] avoid array ( add steps if the avoid blocks are in the way) or I can add one more intermediate target to push the number in one direction first and then in another direction to reach the target. I chose the later approach because this intermediate target was a necessary step in pushing the number and it would not cause unnecessary waste of steps. The other reason is that calculating the heuristic function with the consideration of int[] avoid array is pretty hard to work with.
Another interesting thing is I always give a multiplier to the Manhattan distance or linear conflict in my heuristic function. The reason is that it might take around 5 steps to move a number each step toward a certain distance as described previously in this document, and even more if there are linear conflicts. I over heard PHS works good by eliminating the cost of path, but I feel it might be not optimal since not considering previous path cost might lead to longer solutions. I think my solution is somewhat better by considering more Manhattan distance and linear conflicts by multiply them by a constant, while still considering the cost of previous path. Actually, it might be possible to use statistical methods to determine a better constant or even a moving constant based on inputs to achieve better results in the future.
